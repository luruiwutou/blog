<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阅读记</title>
    <url>/2022/01/19/read_01/</url>
    <content><![CDATA[<h1 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h1><ul>
<li>理想国</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法图解part6</title>
    <url>/2021/12/28/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3part6/</url>
    <content><![CDATA[<h2 id="算法图解part6"><a href="#算法图解part6" class="headerlink" title="算法图解part6"></a>算法图解part6</h2><h3 id="图是什么"><a href="#图是什么" class="headerlink" title="图是什么"></a>图是什么</h3><p><strong>图模拟一组链接</strong></p>
<p>图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。</p>
<h3 id="广度优先搜索———图算法"><a href="#广度优先搜索———图算法" class="headerlink" title="广度优先搜索———图算法"></a>广度优先搜索———图算法</h3><blockquote>
<p>广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多！</p>
</blockquote>
<p>使用广度优先搜索可以:</p>
<ul>
<li> 编写国际跳棋AI，计算最少走多少步就可获胜；</li>
<li>编写拼写检查器，计算最少编辑多少个地方就可以将错拼的单词改写成正确的单词，如将READED改为READER需要编辑一个地方；</li>
<li>根据你的人际关系网格找到关系最近的医生。</li>
</ul>
<p>可以帮助回答两类问题</p>
<ol>
<li>从节点A出发，有前往节点B的路径吗？</li>
<li>从节点A出发，前往B的哪条路径最短？</li>
</ol>
<p>此时我们需要确定顺序时（满足第二类问题），需要按添加顺序进行检查时就引入了<strong>队列（<code>queue</code>）</strong></p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列类似于栈，你不能随机访问队列中的元素。它只支持两种操作：<strong>入队</strong>和<strong>出队</strong></p>
<p>队列是一种<strong>先进先出（First In First Out，FIFO）</strong>的数据结构，而栈式一种<strong>后进后出（Last In First Out,  LIFO）</strong>的数据结构</p>
<h4 id="实现图"><a href="#实现图" class="headerlink" title="实现图"></a>实现图</h4><p>图由多个节点组成，内阁节点都与临近节点相连，如果表示类似于“你-&gt;Bob”这样的关系呢？</p>
<p>此时引入上期了解过的<strong>散列表</strong></p>
<table>
    <tr>         
        <td rowspan="3">你</td><td>ALICE</td> 
    </tr>
    <tr>         
        <td>CLIARE</td>    
    </tr>    
    <tr>         
        <td>BOB</td>
    </tr>
</table>

<p> 表示这种映射关系的Python代码入下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph&#123;<span class="string">&quot;you&quot;</span>&#125; = &#123;<span class="string">&quot;alice&quot;</span>,<span class="string">&quot;bob&quot;</span>,<span class="string">&quot;cliare&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>同理，你的邻居的邻居也可如此表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph&#123;&quot;you&quot;&#125; = [&quot;alice&quot;,&quot;bob&quot;,&quot;cliare&quot;]</span><br><span class="line">graph&#123;&quot;alice&quot;&#125; = [&quot;peggy&quot;]</span><br><span class="line">graph&#123;&quot;bob&quot;&#125; = [&quot;anuj&quot;,&quot;peggy&quot;]</span><br><span class="line">graph&#123;&quot;cliare&quot;&#125; = &quot;thom&quot;,&quot;jonny&quot;]</span><br><span class="line">graph&#123;&quot;anuj&quot;&#125; = []</span><br><span class="line">graph&#123;&quot;peggy&quot;&#125; = []</span><br><span class="line">graph&#123;&quot;thom&quot;&#125; = []</span><br><span class="line">graph&#123;&quot;jonny&quot;&#125; = []</span><br></pre></td></tr></table></figure>

<p>Anuj、Peggy、Thom和Jonny都没有邻居，那这种情况叫什么？</p>
<p><strong>有向图：</strong>有指向他们的箭头，但是没有从他们出发指向其他人的箭头，被称为有向图（directed graph）</p>
<p><strong>无向图：</strong>没有箭头，直接相连的节点互为邻居。</p>
<h5 id="如何实现查找自己的关系网？"><a href="#如何实现查找自己的关系网？" class="headerlink" title="如何实现查找自己的关系网？"></a>如何实现查找自己的关系网？</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//示例</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">name</span>)</span></span><br><span class="line"><span class="function">	<span class="title">search_queue</span> = <span class="title">deque</span>()//创建一个队列</span></span><br><span class="line"><span class="function">    <span class="title">search_queue</span> += <span class="title">graph</span>[<span class="title">name</span>]//将你的邻居加入队列</span></span><br><span class="line"><span class="function">    <span class="title">searched</span> =[] //这个数组记录用于检查过的人</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">search_queue</span>:</span></span><br><span class="line">        person = search_queue.popleft()//取出其中的第一个人</span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched: //仅当这个人没检查过时才检查</span><br><span class="line">            <span class="keyword">if</span> penson_is_you_need(person)://检查这个人是否是你需要的</span><br><span class="line">                <span class="built_in">print</span> person + <span class="string">&quot; is you need!&quot;</span> //是你需要的人</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span> //找到了 终止</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                search_queue +=graph[person] //不是你需要的，将这个人的邻居加入搜索队列</span><br><span class="line">                searched.append(person) //标记为检查过</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span> //你的关系网里没有你需要的人</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">search(<span class="string">&quot;you&quot;</span>)</span><br><span class="line">         </span><br></pre></td></tr></table></figure>



<h4 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h4><p>因为你沿着每条边前行，因此运行时间至少为O(边数)，加上使用了队列，其中包含要检查的每个人，将每个人添加到队列需要的时间是固定的即为O(1)，因此对每个人都这样做的总时间为O(人数)。</p>
<p>所以，广度优先搜索的运行时间为O(人数+边数)，通常写作O(V+E)，其中V为顶点（vertice）数，E为边数。</p>
<h6 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h6><p>如果任务A以来任务B，在列表中任务A就必须在任务B后面，这被称为<strong>拓扑排序</strong>，使用它可根据图创建一个有序列表，类似于“家谱”，这种图被称为树。树是有一种特殊的图，其中没有往后指的边。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>广度优先搜索指出是否有从A到B的路径。</li>
<li>如果有，广度优先搜索将找出最短路径。</li>
<li>面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。</li>
<li>有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama-&gt;adit表示rama欠adit钱。</li>
<li>无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约会，而rachel也与ross约会“。</li>
<li>队列是先进先出（FIFO）的，栈式后进先出（LIFO）的</li>
<li>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。</li>
<li>对于检查过的人，务必不要再去检查，否则可能导致无限循环。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法图解part5</title>
    <url>/2021/12/09/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3part5/</url>
    <content><![CDATA[<h2 id="算法图解part5"><a href="#算法图解part5" class="headerlink" title="算法图解part5"></a>算法图解part5</h2><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><blockquote>
<p>你几乎不用自己去实现散列表，因为你使用的编程语言提供了散列表实现。你可以各种语言提供的散列表，并假定能够获得平均情况下的性能：<strong>常量时间</strong></p>
</blockquote>
<p>散列表可以理解为Java语言中的hashmap，它拥有几个特征：</p>
<ul>
<li>散列函数<ul>
<li>必须满足的一些要求<ul>
<li>他必须是一致的。每次相同的输入必须得到相同的结果。</li>
<li>它应将不同的输入映射到不同的数字。（此时就引入了下一个环节的<strong>冲突</strong>）</li>
<li>它知道数组的大小，只会返回有效的索引</li>
</ul>
</li>
</ul>
</li>
<li>应用案例<ul>
<li>将散列表用于查找/模拟映射关系<ul>
<li>电话簿</li>
<li>NDS解析（域名转换为IP）</li>
</ul>
</li>
<li>防止重复<ul>
<li>投票</li>
</ul>
</li>
<li>将散列表用作缓存/记住数据<ul>
<li>Web缓存常用数据，用以加速网络加载，提高用户体验</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><blockquote>
<p>前面提到的散列函数总是将不同的键映射到数组的不同位置，实际上是几乎不可能的。</p>
</blockquote>
<p>如果两个键映射到一个位置的时候，就在这个位置存储一个链表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[k]-&gt;[]-&gt;[]-[] //链表</span><br><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">数组</span><br></pre></td></tr></table></figure>

<p>经验教训：</p>
<ul>
<li><strong>散列函数很重要</strong>。前面的散列函数将所有的键将所有的键都映射到一个位置，而理想的情况是，散列函数将键均匀地映射到散列表的不同位置。</li>
<li>如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长！</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>散列表的性能</p>
<table>
<thead>
<tr>
<th></th>
<th>散列表平均情况(常量时间)</th>
<th>散列表最糟情况</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>查找</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>在平均情况下，散列表的查找（获取给定索引处的值）速度和数组一样快，而插入和删除的速度和链表一样快，因此它兼具两者的优点！</p>
<p>但是在最糟情况下，散列表的各种操作的速度都很慢，因此使用散列表时，避开最糟情况至关重要。</p>
<p>如何避免：</p>
<ul>
<li>较低的填装因子；<ul>
<li>散列表包含的元素数/位置总数。</li>
<li>填装因子越低，发生冲突的可能性越小。散列表的性能越高。</li>
<li>调整散列表长度的工作开销很大，但是平均而言，即使这样也不影响散列表操作时间O(1)。</li>
</ul>
</li>
<li>良好的散列函数。<ul>
<li>SHA函数等等，可后续了解</li>
</ul>
</li>
</ul>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。</p>
<ul>
<li>你可以结合散列函数和数组来创建散列表。</li>
<li>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。</li>
<li>散列表的查找、插入和删除速度都非常快。</li>
<li>散列表适合用于模拟映射关系。</li>
<li>一旦填装因子超过0.7，就该调整散列表的长度。</li>
<li>散列表可用于缓存数（例如，在Web服务器）。</li>
<li>散列表非常适合用于防止重复。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法图解part4</title>
    <url>/2021/12/08/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3part4/</url>
    <content><![CDATA[<h3 id="算法图解小结part4"><a href="#算法图解小结part4" class="headerlink" title="算法图解小结part4"></a>算法图解小结part4</h3><h4 id="分而治之（divide-and-conquer，D-amp-C）"><a href="#分而治之（divide-and-conquer，D-amp-C）" class="headerlink" title="分而治之（divide and conquer，D&amp;C）"></a>分而治之（divide and conquer，D&amp;C）</h4><blockquote>
<p>一种著名的递归式问题解决方法</p>
</blockquote>
<p>使用D&amp;C解决问题的过程包括两个步骤</p>
<ul>
<li>找出极基线条件，这种条件必须尽可能简单。</li>
<li>不断将问题分拣（或者说缩小规模），直至符合基线条件。</li>
</ul>
<h4 id="快速排序代码demo"><a href="#快速排序代码demo" class="headerlink" title="快速排序代码demo"></a>快速排序代码demo</h4><blockquote>
<p>归纳证明：基线条件和归纳条件。<br>对于快速排序，在基线条件中，证明这种算法对空数组或包含一个元素的数组管用。在归纳条件中，证明如果快速排序对包含一个元素的数组管用，对包含两个元素的数组也将管用，对包含三个元素的数组也将管用，以此类推。因此可以说，快速排序对任何长度的数组都管用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;<span class="comment">//基线条件：为空或者只包含一个元素的数组是“有序”的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = arr[<span class="number">0</span>];<span class="comment">//选择基准值</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.concatenate(Arrays.append(quickivotArr(pivot, arr), pivot) ,quickivot(gtPipivot, arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**、</span></span><br><span class="line"><span class="comment">     * 获取所有小于基准值的子数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pivot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ltPivotArr(<span class="keyword">int</span> pivot, <span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; pivot) &#123;</span><br><span class="line">                res = Arrays.append(res, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有大于基准值的子数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pivot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] gtPivotArr(<span class="keyword">int</span> pivot, <span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; pivot) &#123;</span><br><span class="line">                res = Arrays.append(res, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。</li>
<li>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(log n)。</li>
<li>大O表示法的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。（它们的运行时间都是n*log n）</li>
<li>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长，O(log n)的速度比O(n)快得多。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法图解小结part1-3</title>
    <url>/2021/12/07/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3part1-3/</url>
    <content><![CDATA[<h2 id="算法小结"><a href="#算法小结" class="headerlink" title="算法小结"></a>算法小结</h2><h3 id="PART-1-算法简介"><a href="#PART-1-算法简介" class="headerlink" title="PART 1 算法简介"></a>PART 1 算法简介</h3><ul>
<li>二分查找的速度比简单查找快得多</li>
<li>O(log n)比O(n)快，需要搜索的元素越多，前者比后者快的越多</li>
<li>算法运行时间并不以秒为单位</li>
<li>算法运行时间是从其增速的角度度量的</li>
<li>算法运行时间用大O表示法表示</li>
</ul>
<h3 id="PART-2-选择排序"><a href="#PART-2-选择排序" class="headerlink" title="PART 2 选择排序"></a>PART 2 选择排序</h3><ul>
<li>计算机内存犹如一大堆抽屉</li>
<li>需要存储多个元素时，可使用数组或链表</li>
<li>数组的元素都在一起</li>
<li>链表的元素是分开的，其中每个元素都存储了下一个元素的地址</li>
<li>数组的读取速度很快，O(1)</li>
<li>链表的插入和删除速度很快</li>
<li>在同一个数组中，所有元素的类型都必须相同（都为int、double等）</li>
</ul>
<h3 id="PART-3-递归"><a href="#PART-3-递归" class="headerlink" title="PART 3 递归"></a>PART 3 递归</h3><ul>
<li>递归指的是调用自己的函数</li>
<li>每个递归函数都有两个条件：基线条件和递归条件</li>
<li>栈有两种操作：压入和弹出</li>
<li>所有函数调用都进入调用栈</li>
<li>调用栈可能很长，这将占用大量的内存（可使用尾递归，避免栈溢出）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
